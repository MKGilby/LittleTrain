{ -[Name]-------------------------------------------

   MKSZTSZ Visual Component Collection for SDL2

                                            EditBox

  --------------------------------------------------

  -[Disclaimer]-------------------------------------

             You can freely distribute it
             under the GNU GPL Version 2.

   Written by Gilby/MKSZTSZ
   Hungary, 2022

  --------------------------------------------------

  -[Description]------------------------------------

   It is a simple text edit box, where the user can
   enter any text input needed for the program.
   You can set it up by properties or use an INI file:

     EditBox1.SetupCommand('Y=20');
     EditBox1.SetupCommand('Height=16');
     
   You can write multiple commands in one line:
     EditBox1.SetupCommand('Y=20|Height=16');
     
     
   Valid commands are:
   (n - numeric, s - string, rrggbb - HTML RGB code)

    For positioning the editbox on the screen:

     X=n
     Y=n
     Width=n
     Height=n
     AlignX=s (left, center, right)
     AlignY=s (top, center, bottom)

    Text properties:

     Font=n         (in MultiFont)
     TextAlign=s    (left, center, right)
     TextOffsetY=n  (to center the text within a row
                     if autocentering is not accurate)
     TextCase=s     (upper, lower, normal)
     PasswordChar=c (if set, this char will be shown instead of typed text)
     MaxLength=n

    Draw mode:

     Background=rrggbb
     Transparent=n

     Transparency mode:
       1 - Transparent. The object gets the image of the
         area will be used, and uses it as background.
         When execution finished, it restores the background.
       0 - Not transparent. Editbox uses background color
         specified in BACKGROUND file.
         
    Cursor:
    
     CursorChar=c   (default='_')
     CursorBlinkRate=n (blinks once in n cycles,
       eg. if n=60 and FPS is set to 60, blinks once in a second)
  --------------------------------------------------

}

// Version info:
//
//  V1.00: Gilby
//         * Initial creation from vcc_Editbox

{$ifdef fpc}
  {$mode delphi}
  {$smartlink on}
{$endif}

unit vcc_EditBox2;

interface

uses Classes, Font2Unit, MKMouse2, MK_SDL2, MKINIFile, FontList2Unit;

type
  TTextCase=(tcDontCare,tcUppercase,tcLowercase);

  TEditBox=class(TMouseObject)
    constructor Create; overload;
    constructor Create(iINI:TINIFile;iSection:string;iFonts:TFontList); overload;
    procedure Draw; override;
    procedure Move; virtual;
    procedure ExecuteSelf; virtual;
  protected
    fText:string;
    fTextAlign:integer;
    fTextAlignPointX:integer;

    fFont:TFont;
    fTextOffsetY:integer;

    fPasswordChar:char;
    fCursorChar:char;
    fMaxLength:integer;

    fColors:array[0..2] of integer;
    fTransparent:boolean;

    fShowCursor:boolean;
    fCursorBlinkRate:integer;
    fCursorBlinkRateCounter:integer;
    fBackgroundColor:integer;
    fTextCase:TTextCase;
    fFinished:boolean;
    procedure fSetLeft(value:integer);
    procedure fSetWidth(value:integer);
    procedure fSetTextAlign(value:integer);
    procedure fSetMaxLength(value:integer);
    procedure fSetText(value:string);
  public
    property Text:string read fText write fSetText;
    property ShowCursor:boolean read fShowCursor write fShowCursor;
    property TextAlign:integer read fTextAlign write fSetTextAlign;
    property Left:integer read fLeft write fSetLeft;
    property Top:integer read fTop write fTop;
    property Width:integer read fWidth write fSetWidth;
    property Height:integer read fHeight write fHeight;
    property BackgroundColor:integer read fBackgroundColor write fBackgroundColor;
    property Font:TFont read fFont write fFont;
    property TextOffsetY:integer read fTextOffsetY write fTextOffsetY;
    property Transparent:boolean read fTransparent write fTransparent;
    property MaxLength:integer read fMaxLength write fSetMaxLength;
    property TextCase:TTextCase read fTextCase write fTextCase;
    property PasswordChar:char read fPasswordChar write fPasswordChar;
    property CursorChar:char read fCursorChar write fCursorChar;
    property CursorBlinkRate:integer read fCursorBlinkRate write fCursorBlinkRate;
    property Finished:boolean read fFinished write fFinished;
  end;

implementation

uses SysUtils, MKToolBox, Logger;

const Fstr='vcc_EditBox.pas, ';
      Version='3.08';

constructor TEditBox.Create;
begin
  inherited Create;
  fLeft:=0;
  fTop:=0;
  fWidth:=256;
  fHeight:=32;
  fTransparent:=false;
  fFont:=nil;
  fTextAlign:=mjLeft;
  fTextAlignPointX:=fLeft;
  fTextOffsetY:=0;
  fBackgroundColor:=0;
  fMaxLength:=64;
  fTextCase:=tcDontCare;
  fPasswordChar:=#0;
  fCursorChar:='_';
  fCursorBlinkRate:=60;
  fCursorBlinkRateCounter:=0;
end;

constructor TEditBox.Create(iINI:TINIFile;iSection:string;iFonts:TFontList);
var s:string;
begin
  inherited Create;
  Left:=iINI.ReadInteger(iSection,'Left',0);
  Top:=iINI.ReadInteger(iSection,'Top',0);
  Width:=iINI.ReadInteger(iSection,'Width',64);
  Height:=iINI.ReadInteger(iSection,'Height',64);
  TextAlign:=strtoint(decode(iINI.ReadString(iSection,'TextAlign','Left'),'Center,1,Right,2,0'));
  TextOffsetY:=iINI.ReadInteger(iSection,'TextOffsetY',0);
  s:=iINI.ReadString(iSection,'Font','not defined');
  Font:=iFonts[s];
  if Font=nil then raise Exception.Create(Format('Font not found! (%s)',[s]));
  BackgroundColor:=iINI.ReadInteger(iSection,'BackgroundColor',0);
  Transparent:=iINI.ReadBool(iSection,'Transparent',false);
  MaxLength:=iINI.ReadInteger(iSection,'MaxLength',64);
  s:=uppercase(iINI.ReadString(iSection,'TextCase','Normal'));
  if s='UPPER' then TextCase:=tcUppercase
  else if s='LOWER' then TextCase:=tcLowercase
  else TextCase:=tcDontCare;
  PasswordChar:=(iINI.ReadString(iSection,'PasswordChar',#0)+#0)[1];
  CursorChar:=(iINI.ReadString(iSection,'CursorChar','_')+'_')[1];
  CursorBlinkRate:=iINI.ReadInteger(iSection,'CursorBlinkRate',60);
  fCursorBlinkRateCounter:=0;
end;

procedure TEditBox.fSetTextAlign(value:integer);
begin
  fTextAlign:=value;
  case fTextAlign of
    mjLeft:fTextAlignPointX:=fLeft;
    mjCenter:fTextAlignPointX:=fLeft+fWidth div 2;
    mjRight:fTextAlignPointX:=fLeft+fWidth;
  end;
end;

procedure TEditBox.fSetLeft(value:integer);
begin
  fLeft:=value;
  case fTextAlign of
    mjLeft:fTextAlignPointX:=fLeft;
    mjCenter:fTextAlignPointX:=fLeft+fWidth div 2;
    mjRight:fTextAlignPointX:=fLeft+fWidth;
  end;
end;

procedure TEditBox.fSetWidth(value:integer);
begin
  fWidth:=value;
  case fTextAlign of
    mjLeft:fTextAlignPointX:=fLeft;
    mjCenter:fTextAlignPointX:=fLeft+fWidth div 2;
    mjRight:fTextAlignPointX:=fLeft+fWidth;
  end;
end;

procedure TEditBox.fSetMaxLength(value:integer);
begin
  fMaxLength:=value;
  if length(fText)>fMaxLength then fText:=copy(fText,1,fMaxLength);
end;

procedure TEditBox.fSetText(value:string);
begin
  fText:=copy(value,1,fMaxLength);
end;

procedure TEditBox.Draw;
var s:string;
begin
  if not fTransparent then Bar(fLeft,fTop,fWidth,fHeight,fBackgroundColor);
  if fPasswordChar=#0 then s:=Text
                      else s:=replicate(fPasswordChar,length(Text));
  fFont.OutText(s,fTextAlignPointX,fTop+fTextOffsetY,fTextAlign);
  if fShowCursor and (fCursorBlinkRateCounter<fCursorBlinkRate div 2) then begin
    case fTextAlign of
      mjLeft:fFont.OutText(fCursorChar,fTextAlignPointX+fFont.TextWidth(s),fTop+fTextOffsetY,fLeft);
      mjCenter:fFont.OutText(fCursorChar,fTextAlignPointX+(fFont.TextWidth(s) div 2),fTextOffsetY+fTop,fLeft);
      mjRight:fFont.OutText(fCursorChar,fTextAlignPointX,fTextOffsetY+fTop,fLeft);
    end;
  end;
  inc(fCursorBlinkRateCounter);
  if fCursorBlinkRateCounter=fCursorBlinkRate then fCursorBlinkRateCounter:=0;
end;

procedure TEditBox.Move;
var c:char;
begin
  c:=ReadkeyEx(false);
  if c<>#255 then begin
    if fTextCase=tcUppercase then c:=upcase(c)
    else if fTextCase=tcLowercase then
      if c in ['A'..'Z'] then c:=chr(ord(c)+32);
    case c of
      #0:c:=ReadkeyEx(true);
      #8:if length(Text)>0 then delete(fText,length(fText),1);
      #1..#7:;
      #9..#31:;
    else
      if length(text)<fMaxLength then Text:=Text+c;
    end;
    if c in [#27,#13] then
      fFinished:=true;
  end;
end;

procedure TEditBox.ExecuteSelf;
begin
  ClearKeyBuffer;
  repeat
    Draw;
//    if fTransparent then PutImage(fLeft,fTop,atm)
//                    else bar(fLeft,fTop,fRight,fBottom,fColors[0],fColors[1],fColors[2]);
//    if fPasswordChar=#0 then fFont.OutText(Text,fAlignPointX,fTextOffsetY,fTextAlign)
//                        else fFont.OutText(replicate(fPasswordChar,length(Text)),fAlignPointX,fTextOffsetY,fTextAlign);
    Flip;
    Move;
  until Finished;
end;

initialization
  Log.LogStatus(Fstr+'version '+Version,'uses');

end.

