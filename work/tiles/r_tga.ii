{ TGA file reader V1.00 -- Freeware -- Written by Gilby/MKSZTSZ }

{ Result will be always 24 bit true color pixelstream. (RGB) }

procedure ReadTGA(FileName:String;var wid,hei:integer;var p);
var f:file;
    iif,cmap,itc,cmes,ips,idb:byte;
    cmo,cml,oX,oY,wi,he:longint;
    tmp:word;
    i,j,ii:longint;
    pp:pointer;b:byte;
    pal:array[0..255,0..2] of byte;
begin
  pp:=@p;
  if pos('.',filename)=0 then filename+='.TGA';
  assign(f,Filename);
  {$i-} reset(f,1); {$i+}
  if ioresult<>0 then exit;
  cmo:=0;cml:=0;oX:=0;oY:=0;wi:=0;he:=0;
  blockread(f,iif,1);   // Image Identifier Field
  blockread(f,cmap,1);  // Color Map Type
  blockread(f,itc,1);   // Image Type Code
  blockread(f,cmo,2);   // Color Map Origin
  blockread(f,cml,2);   // Color Map Length
  blockread(f,cmes,1);  // Color Map Entry Size
  blockread(f,oX,2);    // Origin X
  blockread(f,oY,2);    // Origin Y
  blockread(f,wi,2);    // Width
  blockread(f,he,2);    // Height
  blockread(f,ips,1);   // Image Pixel Size
  blockread(f,idb,1);   // Image Descriptor Byte
  seek(f,filepos(f)+iif);  // Skip Image Identifier Field
  wid:=wi;
  hei:=he;
  case itc of
    0:writeln('RTGA: No image data included in file!');
// ------------------ Paletted ------------------------
    1:begin
        blockread(f,pal,cml*3);
        for ii:=0 to he-1 do begin
          if (idb and $20)=0 then i:=he-ii-1
                             else i:=ii;
          for j:=0 to wi-1 do begin
            blockread(f,b,1);
            move(pal[b],(pp+j*3+i*wi*3)^,3);
          end;
        end;
      end;
//------------------- Uncompressed RGB ------------------------------
    2:begin
        if (oX<>0) or (oY<>0) then writeln('RTGA: Ignoring Origin settings!');
        for ii:=0 to he-1 do begin
          if (idb and $20)=0 then i:=he-ii-1
                             else i:=ii;
          for j:=0 to wi-1 do begin
            case ips of
             16:begin
                  blockread(f,tmp,2);
                  case (idb and 15) of
                    0:begin
                        byte((pp+j*3+i*wi*3)^):=(tmp and $f800)>>8;
                        byte((pp+j*3+i*wi*3+1)^):=(tmp and $07e0)>>3;
                        byte((pp+j*3+i*wi*3+2)^):=(tmp and $001e)<<3;
//                        byte(ptr(0,ofs(p)+j*3+i*wi*3)^):=(tmp and $f800)>>8;
//                        byte(ptr(0,ofs(p)+j*3+i*wi*3+1)^):=(tmp and $07e0)>>3;
//                        byte(ptr(0,ofs(p)+j*3+i*wi*3+2)^):=(tmp and $001e)<<3;
                      end;
                    1:begin
                        byte((pp+j*3+i*wi*3)^):=(tmp and $7c00)>>7;
                        byte((pp+j*3+i*wi*3+1)^):=(tmp and $03e0)>>2;
                        byte((pp+j*3+i*wi*3+2)^):=(tmp and $001e)<<3;
                      end;
                    else begin writeln('RTGA: Illegal Image Descriptor Byte!');exit;end;
                  end;
                end;
             24:blockread(f,(pp+j*3+i*wi*3)^,3);
             32:begin
                  blockread(f,(pp+j*3+i*wi*3)^,3);
                  blockread(f,tmp,1);
                end;
              else begin writeln('RTGA: Illegal Image Pixel Size!');exit;end;
            end;
          end;
        end;
      end;
//-------------------------------------------------------------------
    3:writeln('RTGA: Black and white images are not supported!');
    9:writeln('RTGA: RLE encoded images are not supported yet!');
   10:writeln('RTGA: RLE encoded images are not supported yet!');
   32:writeln('RTGA: Compressed images are not supported!');
   33:writeln('RTGA: Compressed images are not supported!');
   else writeln('RTGA: Unkown image type!');
  end;
  close(f);
end;
